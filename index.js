'use strict'

/**
 * TODO implement bodyparser
 * 
 * How to use:
 * 
 * Module takes in scheme, returns middleware for parameter validation
 * 
 * Scheme: { key_: type[4] }
 *  key         - field name
 *  _ after key - parameter is NOT required
 * type         - data type expected (int, bool, str, float, datetime)
 * []           - parameter is an array
 * [x]          - parameter is an array of fixed length x
 */
const bodyParser = require("body-parser")
const parseUrlencodedBody = bodyParser.urlencoded({extended: true})
const parseJSONBody = bodyParser.json({strict: true})

let mutators = { // Mutators return undefined when values are invalid
    int: v => {
        if (isNaN(v)) return
        return parseInt(v, 10)
    },
    bool: v => {
        v = String(v).toLowerCase()
        switch (v) {
            case 't':
            case 'true':
            case '1':
                return true
            case 'f':
            case 'false':
            case '0':
            case '-1':
                return false
            default:
                return
        }
    },
    str: v => {
        if (typeof v === 'object') return
        return String(v)
    },
    float: v => {
        if (isNaN(v)) return
        return parseFloat(v)
    },
    datetime: v => {
        if (typeof v === 'string') {
            let result = Date.parse(v)
            if (isNaN(result)) return
            return result
        } else if (typeof v === 'number' && v >= 0) {
            return new Date(v)
        } else {
            return undefined
        }
    },
}
// Aliases
mutators.integer = mutators.int
mutators.boolean = mutators.bool
mutators.string = mutators.str
mutators.number = mutators.numeric = mutators.num = mutators.float
mutators.date = mutators.time = mutators.timestamp = mutators.datetime

// Builds the scheme object that is used by needs to validate and format incoming parameters
function buildScheme(_scheme, _parent) {
    let scheme = {}
    
    for (let key in _scheme) {
        let current_key = _parent ? _parent + '['+key+']' : key
        let definition = _scheme[key]
        let options = { type: null, mutator: null, is_arr: false, arr_len: null,  required: true }
        let lastCharIndex = definition.length - 1
        
        if (typeof definition === 'function') {
            // NOTE Custom mutators must return UNDEFINED on invalid value
            options.type = 'mutator'
            options.mutator = definition
        } else if (typeof definition === 'object') {
            options.type = buildScheme(definition, current_key)
        } else if (typeof definition === 'string') {
            if (definition[lastCharIndex] === ']') {
                let arrBegin = definition.indexOf('[')
                options.is_arr = true
                
                if (lastCharIndex - arrBegin > 1) {
                    let arrlen = definition.substr(arrBegin+1, lastCharIndex - arrBegin - 1)
                    if (arrlen) {
                        if (isNaN(arrlen)) throw Error('Invalid route parameter array length')
                        options.arr_len = parseInt(arrlen, 10)
                    }
                }
                
                definition = definition.substr(0, arrBegin)
            }
            
            if (!mutators[definition]) {
                throw Error('Invalid route parameter type ' + definition)
            }
        } else {
            throw Error('Invalid route parameter scheme on key ' + current_key)
        }
        
        if (key[key.length-1] === '_') {
            key = key.substr(0, key.length-1)
            options.required = false
        }
        
        options.type = options.type || definition
        scheme[key] = options
    }
    
    return scheme
}

function isEmpty(obj) {
    return Object.keys(obj).length === 0
}

/**
 * @param options
 * @param options.strict        fail if passed unexpected parameters (default true)
 * @param options.onError       error handler
 * 
 * 
 * onError error handler format:
 * @param options
 * @param options.request   the request object
 * @param options.message   the message generated by the error
 * @param options.parameter the parameter which caused the error
 * @param options.value     the value of the parameter causing the error
 * @param options.expected  boolean flag for if this parameter is not a part of the schema 
 * @returns                 An error object to be forwarded via "next"
 * 
 * TODO NOTE    Errors can be ignored by passing a function to onError that returns undefined always.
 *              This allows for soft failing on invalid params. This function can also be used to log the errors.  
 */
class Needs {
    
    constructor(options) {
        options = options || {}
        this.strict = options.strict === undefined ? true : options.strict
        this.onError = (request, msg, key, value, expected) => {
            if (typeof options.onError === 'function') {
                return options.onError({
                    request: request,
                    message: msg,
                    parameter: key,
                    value: value,
                    expected: expected
                })
            } else {
                return { message: msg, parameter: key, value: value, expected: expected }
            }
        }
    }

    params(_scheme) {
        let scheme = buildScheme(_scheme)
        return (req, res, next) => {
            // Parse the body, if necessary
            let checkUrlencoded = () => {
                if (req.body === undefined || isEmpty(req.body)) {
                    parseUrlencodedBody(req, res, checkJSON)
                } else {
                    process()
                }
            }
            let checkJSON = () => {
                if (req.body === undefined || isEmpty(req.body)) {
                    parseJSONBody(req, res, process)
                } else {
                    process()
                }
            }
            // Perform the actual validation
            let process = () => {
                let data = req.body
                if (!data || isEmpty(data)) data = req.query || {}
                next(this.validate(scheme, data, req))
            }
            
            checkUrlencoded()
            // else process()
        }
    }

    validate(scheme, data, req, _parent) {
        let count = 0 // Counter used to count processed fields and detect any extraneous fields
        for (let key in scheme) {
            // For returning correct parameter if errored
            let _current = _parent ? _parent+'['+key+']' : key
            
            if (data[key] !== undefined) {
                if (typeof scheme[key].type === 'object') {
                    if (typeof data[key] !== 'object') {
                        return this.onError(req, 'Invalid parameter type, object expected', _current, data[key], true)
                    }
                    
                    let err = this.validate(scheme[key].type, data[key], req, _current)
                    if (err) return err
                } else {
                    let func = scheme[key].type === 'mutator' ? scheme[key].mutator : mutators[scheme[key].type]
                    
                    if (scheme[key].is_arr) {
                        if (!Array.isArray(data[key])) data[key] = [data[key]]
                        if (scheme[key].arr_len && data[key].length !== scheme[key].arr_len) {
                            return this.onError(req, 'Array length must be ' + scheme[key].arr_len, _current, data[key].length, true)
                        }
                        for (let i = 0; i < data[key].length; ++i) {
                            let val = func(data[key][i])
                            if (val === undefined) {
                                return this.onError(req, 'Invalid parameter value', _current, data[key], true)
                            }
                            data[key][i] = val
                        }
                    } else {
                        let val = func(data[key])
                        if (val === undefined) {
                            return this.onError(req, 'Invalid parameter value', _current, data[key], true)
                        }
                        data[key] = val
                    }
                }
                
                ++count
            } else if (scheme[key].required) {
                if (typeof scheme[key].type === 'object') {
                    let _type = scheme[key].type
                    while (typeof _type === 'object') {
                        let _keys = Object.keys(_type)
                        _current += '['+_keys[0]+']'
                        _type = _type[_keys[0]].type
                    }
                }
                
                return this.onError(req, 'Missing expected parameter', _current, data[key], true)
            }
        }
        
        if (this.strict && count !== Object.keys(data).length) {
            // get the first unexpected parameter and report as unexpected
            for (let key in data) {
                if (!scheme[key]) return this.onError(req, 'Unexpected parameter', _parent ? _parent+'['+key+']' : key, data[key], false)
            }
        }
    }
    
    // Disallow any parameters from being sent to this endpoint
    nothing(req, res, next) {
        let data = req.body || req.query || {}
        let keys = Object.keys(data)
        if (keys.length) return next(this.onError(req, 'Unexpected parameter', keys[0], data[keys[0]], false))
        next()
    }
}

module.exports = options => { return new Needs(options) }